def merge_sprint_rows(self, rows: List[Dict[str, Any]]):
    """
    Upsert into dbo.jira_sprint safely:
      - Python-side dedupe by (ProjectName,SprintName) with trim + case-fold
      - Drop identity columns from source
      - SQL-side dedupe of VALUES (keep latest by SprintCompletedDate/SprintEndDate)
      - Case/whitespace-insensitive ON using COLLATE DATABASE_DEFAULT
    """
    if not rows:
        return

    # Ensure table exists (PK remains SprintId IDENTITY)
    self._create_table_if_not_exists(self.TABLE_SPRINT, self.SPRINT_COLS, self.SPRINT_PK)

    # ---- Python-side normalize + dedupe ----
    def _norm(s): return None if s is None else str(s).strip()
    dedup = {}
    for r in rows:
        pn = _norm(r.get("ProjectName"))
        sn = _norm(r.get("SprintName"))
        if not pn or not sn:
            continue
        r = {**r, "ProjectName": pn, "SprintName": sn}
        k = (pn.casefold(), sn.casefold())
        # keep the 'latest' metadata if duplicates in the same batch
        cur = dedup.get(k)
        if cur is None:
            dedup[k] = r
        else:
            d_new = r.get("SprintCompletedDate") or r.get("SprintEndDate")
            d_old = cur.get("SprintCompletedDate") or cur.get("SprintEndDate")
            if d_new and (not d_old or d_new > d_old):
                dedup[k] = r
    rows = list(dedup.values())
    if not rows:
        return

    cn = self.connect()
    cur = cn.cursor()

    # ---- drop identity columns from source projection ----
    id_cols = self._identity_columns(self.TABLE_SPRINT)  # e.g., {"SprintId"}
    all_cols = [c for c, _ in self.SPRINT_COLS]
    cols = [c for c in all_cols if c not in id_cols]     # never try to insert/update identities

    key_cols = ("ProjectName", "SprintName")
    src_cols = ", ".join(f"[{c}]" for c in cols)
    tgt_cols = src_cols
    assignments = ", ".join([f"T.[{c}] = S.[{c}]" for c in cols if c not in key_cols])

    # ---- parameter batching to stay under 2100 params ----
    per_row = len(cols)
    max_rows = max(1, 2000 // per_row)

    def to_params(batch):
        for r in batch:
            for c in cols:
                yield r.get(c)

    i = 0
    n = len(rows)
    while i < n:
        batch = rows[i:i + max_rows]
        i += len(batch)

        row_ph = "(" + ", ".join(["?"] * per_row) + ")"
        values_clause = ", ".join([row_ph] * len(batch))

        # Use a derived table around VALUES and compute ROW_NUMBER() to keep ONE row per key.
        # Emulate NULLS LAST by ordering with a CASE expression.
        merge_sql = f"""
MERGE {self.TABLE_SPRINT} WITH (HOLDLOCK, UPDLOCK) AS T
USING (
    SELECT *
    FROM (
        SELECT V.*,
               ROW_NUMBER() OVER (
                   PARTITION BY
                       LTRIM(RTRIM(V.[ProjectName])) COLLATE DATABASE_DEFAULT,
                       LTRIM(RTRIM(V.[SprintName]))  COLLATE DATABASE_DEFAULT
                   ORDER BY
                       CASE WHEN COALESCE(V.[SprintCompletedDate], V.[SprintEndDate]) IS NULL THEN 1 ELSE 0 END,
                       COALESCE(V.[SprintCompletedDate], V.[SprintEndDate]) DESC
               ) AS rn
        FROM (VALUES {values_clause}) AS V ({src_cols})
    ) D
    WHERE D.rn = 1
) AS S
ON  LTRIM(RTRIM(T.[ProjectName])) COLLATE DATABASE_DEFAULT
    = LTRIM(RTRIM(S.[ProjectName])) COLLATE DATABASE_DEFAULT
AND LTRIM(RTRIM(T.[SprintName]))  COLLATE DATABASE_DEFAULT
    = LTRIM(RTRIM(S.[SprintName]))  COLLATE DATABASE_DEFAULT
WHEN MATCHED THEN
  UPDATE SET {assignments}
WHEN NOT MATCHED BY TARGET THEN
  INSERT ({tgt_cols}) VALUES ({src_cols});
"""
        cur.execute(merge_sql, list(to_params(batch)))

    cur.close()
