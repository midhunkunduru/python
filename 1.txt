def upsert_issues(self, rows: List[Dict[str, Any]]):
    """
    Upsert into dbo.jira_issue using MERGE + VALUES.
    De-duplicates per batch by Issue to avoid PK violations.
    """
    if not rows:
        return

    self._create_table_if_not_exists(self.TABLE_ISSUE, self.ISSUE_COLS, self.ISSUE_PK)
    cn = self.connect()
    cur = cn.cursor()

    cols = [c for c, _ in self.ISSUE_COLS]
    src_cols = ", ".join(f"[{c}]" for c in cols)
    tgt_cols = src_cols
    assignments = ", ".join([f"T.[{c}] = S.[{c}]" for c in cols if c != "Issue"])

    # --- normalize & dedupe by Issue (keep last occurrence) ---
    def _norm_issue(v):
        return None if v is None else str(v).strip()

    dedup: dict[str, Dict[str, Any]] = {}
    for r in rows:
        issue = _norm_issue(r.get("Issue"))
        if not issue:
            continue  # skip rows with missing key
        r = {**r, "Issue": issue}
        dedup[issue] = r
    rows = list(dedup.values())
    if not rows:
        return

    # 2100-parameter limit protection
    per_row_params = len(cols)
    max_rows = max(1, 2000 // per_row_params)

    def to_params(batch):
        for r in batch:
            for c in cols:
                yield r.get(c)

    i = 0
    n = len(rows)
    while i < n:
        batch = rows[i:i + max_rows]
        i += len(batch)

        row_placeholders = "(" + ", ".join(["?"] * per_row_params) + ")"
        values_clause = ", ".join([row_placeholders] * len(batch))

        merge_sql = f"""
MERGE {self.TABLE_ISSUE} WITH (HOLDLOCK) AS T
USING (VALUES {values_clause}) AS S ({src_cols})
  ON T.[Issue] = S.[Issue]
WHEN MATCHED THEN
  UPDATE SET {assignments}
WHEN NOT MATCHED BY TARGET THEN
  INSERT ({tgt_cols}) VALUES ({src_cols});
"""
        params = list(to_params(batch))
        cur.execute(merge_sql, params)

    cur.close()
