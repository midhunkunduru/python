def merge_issue_rows(self, rows: List[Dict[str, Any]]):
    if not rows:
        return

    self._create_table_if_not_exists(self.TABLE_ISSUE, self.ISSUE_COLS, self.ISSUE_PK)
    cn = self.connect()
    cur = cn.cursor()

    cols = [c for c, _ in self.ISSUE_COLS]
    src_cols = ", ".join(f"[{c}]" for c in cols)                 # [Issue],[ProjectName],...
    tgt_cols = src_cols
    assignments = ", ".join([f"T.[{c}] = S.[{c}]" for c in cols if c != "Issue"])

    # Respect SQL Server's 2100 parameter limit
    max_params = 2000  # leave some slack
    per_row_params = len(cols)
    max_rows_per_stmt = max(1, max_params // per_row_params)

    def to_params(batch):
        # Flatten params in the order of `cols`
        for r in batch:
            for c in cols:
                yield r.get(c)

    i = 0
    n = len(rows)
    while i < n:
        batch = rows[i : i + max_rows_per_stmt]
        i += len(batch)

        # Build (VALUES (?, ?, ...), (?, ?, ...), ...)
        one_row_placeholders = "(" + ", ".join(["?"] * per_row_params) + ")"
        values_clause = ", ".join([one_row_placeholders] * len(batch))

        merge_sql = f"""
MERGE {self.TABLE_ISSUE} AS T
USING (VALUES {values_clause}) AS S ({src_cols})
    ON T.Issue = S.Issue
WHEN MATCHED THEN UPDATE SET {assignments}
WHEN NOT MATCHED THEN INSERT ({tgt_cols}) VALUES ({src_cols});
"""
        params = list(to_params(batch))
        cur.execute(merge_sql, params)

    cur.close()
