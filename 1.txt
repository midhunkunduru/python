def _identity_columns(self, table: str) -> set[str]:
    """Return identity columns for a given table."""
    cn = self.connect()
    cur = cn.cursor()
    cur.execute("""
        SELECT c.name
        FROM sys.identity_columns ic
        JOIN sys.columns c ON c.object_id = ic.object_id AND c.column_id = ic.column_id
        WHERE ic.object_id = OBJECT_ID(?)
    """, table)
    names = {row[0] for row in cur.fetchall()}
    cur.close()
    return names


def merge_sprint_rows(self, rows: List[Dict[str, Any]]):
    """
    Upsert into dbo.jira_sprint safely:
      - Drop identity columns from source
      - Python-side dedupe by (ProjectName,SprintName) after trimming/case-folding
      - SQL-side dedupe (keep the latest EventDate) so a single batch never carries multiple for same key
      - Case/whitespace-insensitive ON with COLLATE
    """
    if not rows:
        return

    # Ensure table exists (your PK stays SprintId IDENTITY)
    self._create_table_if_not_exists(self.TABLE_SPRINT, self.SPRINT_COLS, self.SPRINT_PK)

    # --- Normalize + dedupe in Python first (trim + case-fold) ---
    def _norm(s): return None if s is None else str(s).strip()
    dedup = {}
    for r in rows:
        pn = _norm(r.get("ProjectName"))
        sn = _norm(r.get("SprintName"))
        if not pn or not sn:
            continue
        r = {**r, "ProjectName": pn, "SprintName": sn}
        k = (pn.casefold(), sn.casefold())  # robust case-insensitive
        # Keep the row with the latest EventDate if duplicates arrive in the same call
        cur = dedup.get(k)
        if cur is None:
            dedup[k] = r
        else:
            d_new = r.get("SprintCompletedDate") or r.get("SprintEndDate") or r.get("EventDate")
            d_old = cur.get("SprintCompletedDate") or cur.get("SprintEndDate") or cur.get("EventDate")
            if d_new and (not d_old or d_new > d_old):
                dedup[k] = r
    rows = list(dedup.values())
    if not rows:
        return

    cn = self.connect()
    cur = cn.cursor()

    # Drop identity columns from the source projection
    id_cols = self._identity_columns(self.TABLE_SPRINT)
    all_cols = [c for c, _ in self.SPRINT_COLS]
    cols = [c for c in all_cols if c not in id_cols]  # never feed identities

    key_cols = ("ProjectName", "SprintName")
    src_cols = ", ".join(f"[{c}]" for c in cols)
    tgt_cols = src_cols
    assignments = ", ".join([f"T.[{c}] = S.[{c}]" for c in cols if c not in key_cols])

    # param batching under 2100 limit
    per_row = len(cols)
    max_rows = max(1, 2000 // per_row)

    def to_params(batch):
        for r in batch:
            for c in cols:
                yield r.get(c)

    i = 0
    n = len(rows)
    while i < n:
        batch = rows[i:i+max_rows]
        i += len(batch)

        # VALUES rows
        row_ph = "(" + ", ".join(["?"] * per_row) + ")"
        values_clause = ", ".join([row_ph] * len(batch))

        # Use a CTE to:
        #  - define V(...) as the VALUES list
        #  - S(...) pick ONE row per (ProjectName,SprintName) by keeping the latest by EventDate-ish fields
        #  - Normalize in ON via LTRIM/RTRIM + CI collation
        merge_sql = f"""
WITH V ({src_cols}) AS (
    VALUES {values_clause}
),
S AS (
    SELECT *
    FROM (
        SELECT V.*,
               ROW_NUMBER() OVER (
                 PARTITION BY
                   LTRIM(RTRIM([ProjectName])) COLLATE SQL_Latin1_General_CP1_CI_AS,
                   LTRIM(RTRIM([SprintName]))  COLLATE SQL_Latin1_General_CP1_CI_AS
                 ORDER BY
                   COALESCE([SprintCompletedDate],[SprintEndDate],[EventDate]) DESC NULLS LAST,
                   (SELECT 0)
               ) AS rn
        FROM V
    ) x
    WHERE rn = 1
)
MERGE {self.TABLE_SPRINT} WITH (HOLDLOCK, UPDLOCK) AS T
USING S
   ON  LTRIM(RTRIM(T.[ProjectName])) COLLATE SQL_Latin1_General_CP1_CI_AS
       = LTRIM(RTRIM(S.[ProjectName])) COLLATE SQL_Latin1_General_CP1_CI_AS
   AND LTRIM(RTRIM(T.[SprintName]))  COLLATE SQL_Latin1_General_CP1_CI_AS
       = LTRIM(RTRIM(S.[SprintName]))  COLLATE SQL_Latin1_General_CP1_CI_AS
WHEN MATCHED THEN
  UPDATE SET {assignments}
WHEN NOT MATCHED BY TARGET THEN
  INSERT ({tgt_cols}) VALUES ({src_cols});
"""
        cur.execute(merge_sql, list(to_params(batch)))

    cur.close()
