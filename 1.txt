from __future__ import annotations
import json
import logging
import os
import re
from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Optional, Tuple

from .types import parse_dt, parse_bool, parse_float, parse_int, coerce_row_to_schema
from .db import Database

logger = logging.getLogger(__name__)

# ---------- Field rules ----------

@dataclass
class FieldRule:
    name: str
    required: bool = False
    normalize: Optional[Callable[[Any], Any]] = None
    check: Optional[Callable[[Any], bool]] = None
    message: Optional[str] = None

# ---------- Common normalizers & checks ----------

_ALNUM_SOFT = re.compile(r"^[A-Za-z0-9 ._\-:/()\[\],]+$")

def to_trim(v: Any) -> Any:
    return None if v is None else str(v).strip()

def to_dt(v: Any) -> Any:
    dt = parse_dt(v)
    return dt if dt is not None else v

def to_bool(v: Any) -> Any:
    b = parse_bool(v)
    return b if b is not None else v

def to_float(v: Any) -> Any:
    f = parse_float(v);  return f if f is not None else v

def to_int(v: Any) -> Any:
    i = parse_int(v);    return i if i is not None else v

def is_not_null(v: Any) -> bool:
    return v is not None and str(v).strip() != ""

def is_alnum_soft(v: Any) -> bool:
    return bool(_ALNUM_SOFT.match(str(v).strip())) if v is not None else False

def max_len(n: int) -> Callable[[Any], bool]:
    def _chk(v: Any) -> bool:
        return v is None or len(str(v)) <= n
    return _chk

def is_datetime(v: Any) -> bool:
    return parse_dt(v) is not None

# ---------- Validation result ----------

@dataclass
class ValidationResult:
    ok: bool
    errors: Dict[str, str]
    row: Dict[str, Any]

# ---------- Core validator ----------

class RowValidator:
    """Validates a single row against FieldRule definitions."""
    def __init__(self, rules: List[FieldRule]):
        self.rules = rules

    def validate(self, row: Dict[str, Any]) -> ValidationResult:
        out = dict(row)
        errs: Dict[str, str] = {}

        for r in self.rules:
            val = out.get(r.name)

            # normalize first
            if r.normalize:
                try:
                    val = r.normalize(val)
                    out[r.name] = val
                except Exception:
                    errs[r.name] = r.message or f"{r.name} normalization failed"
                    continue

            # required
            if r.required and not is_not_null(val):
                errs[r.name] = r.message or f"{r.name} is required"
                continue

            # check
            if r.check and is_not_null(val):
                try:
                    ok = r.check(val)
                except Exception:
                    ok = False
                if not ok:
                    errs[r.name] = r.message or f"{r.name} failed validation"

        return ValidationResult(ok=(len(errs) == 0), errors=errs, row=out)


class EntityValidator:
    """
    Validates many rows for one entity type (sprint/issue/assignment).
    Can also run a cross-field check after the field checks.
    """
    def __init__(
        self,
        field_rules: List[FieldRule],
        crosscheck: Optional[Callable[[Dict[str, Any]], Dict[str, str]]] = None,
    ):
        self.row_validator = RowValidator(field_rules)
        self.crosscheck = crosscheck or (lambda _row: {})

    def validate_rows(
        self, rows: List[Dict[str, Any]]
    ) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
        good: List[Dict[str, Any]] = []
        bad:  List[Dict[str, Any]] = []

        for r in rows:
            res = self.row_validator.validate(r)
            if res.ok:
                xerrs = self.crosscheck(res.row)
                if xerrs:
                    bad.append({"why": xerrs, "row": r})
                else:
                    good.append(res.row)
            else:
                bad.append({"why": res.errors, "row": r})
        return good, bad


class DataQualityPipeline:
    """
    Orchestrates validation for sprints, issues, assignments, writes quarantine files,
    and coerces types to DB schema before load.
    """
    def __init__(
        self,
        db: Database,
        sprint_rules: List[FieldRule],
        issue_rules: List[FieldRule],
        assign_rules: List[FieldRule],
        sprint_crosscheck: Optional[Callable[[Dict[str, Any]], Dict[str, str]]] = None,
        issue_crosscheck: Optional[Callable[[Dict[str, Any]], Dict[str, str]]] = None,
        assign_crosscheck: Optional[Callable[[Dict[str, Any]], Dict[str, str]]] = None,
        quarantine_dir: str = "./quarantine",
        logger_: Optional[logging.Logger] = None,
    ):
        self.db = db
        self.quarantine_dir = quarantine_dir
        self.logger = logger_ or logging.getLogger(__name__)

        self.sprint_validator = EntityValidator(sprint_rules, sprint_crosscheck)
        self.issue_validator  = EntityValidator(issue_rules,  issue_crosscheck)
        self.assign_validator = EntityValidator(assign_rules, assign_crosscheck)

        os.makedirs(self.quarantine_dir, exist_ok=True)

    # convenience writers
    def _write_quarantine(self, filename: str, records: List[Dict[str, Any]]) -> None:
        if not records:
            return
        path = os.path.join(self.quarantine_dir, filename)
        with open(path, "a", encoding="utf-8") as f:
            for r in records:
                f.write(json.dumps(r, default=str) + "\n")

    def run_and_load(
        self,
        sprint_rows: List[Dict[str, Any]],
        issue_rows: List[Dict[str, Any]],
        assign_rows: List[Dict[str, Any]],
    ) -> Dict[str, int]:
        # Validate
        good_sprints, bad_sprints   = self.sprint_validator.validate_rows(sprint_rows)
        good_issues,  bad_issues    = self.issue_validator.validate_rows(issue_rows)
        good_assigns, bad_assigns   = self.assign_validator.validate_rows(assign_rows)

        # Quarantine
        self._write_quarantine("invalid_sprints.jsonl",   bad_sprints)
        self._write_quarantine("invalid_issues.jsonl",    bad_issues)
        self._write_quarantine("invalid_assignments.jsonl", bad_assigns)

        self.logger.info(
            "Validation: sprints ok=%d bad=%d | issues ok=%d bad=%d | assignments ok=%d bad=%d",
            len(good_sprints), len(bad_sprints),
            len(good_issues),  len(bad_issues),
            len(good_assigns), len(bad_assigns),
        )

        # Coerce to DB types
        good_sprints = [coerce_row_to_schema(r, Database.SPRINT_COLS) for r in good_sprints]
        good_issues  = [coerce_row_to_schema(r, Database.ISSUE_COLS)  for r in good_issues]
        good_assigns = [coerce_row_to_schema(r, Database.ASSIGN_COLS) for r in good_assigns]

        # Load
        self.db.merge_sprint_rows(good_sprints)
        self.db.upsert_issues(good_issues)
        self.db.merge_assign_rows(good_assigns)

        stats = {
            "sprint_ok": len(good_sprints), "sprint_bad": len(bad_sprints),
            "issue_ok":  len(good_issues),  "issue_bad":  len(bad_issues),
            "assign_ok": len(good_assigns), "assign_bad": len(bad_assigns),
        }
        self.logger.info("Load complete: %s", stats)
        return stats

# ---------- Prebuilt rule sets (edit to match all your fields) ----------

SPRINT_RULES_DEFAULT: List[FieldRule] = [
    FieldRule("ProjectName",      required=True,  normalize=to_trim, check=lambda v: is_alnum_soft(v) and max_len(400)(v),
              message="ProjectName required; <=400 chars"),
    FieldRule("SprintName",       required=True,  normalize=to_trim, check=lambda v: is_alnum_soft(v) and max_len(400)(v),
              message="SprintName required; <=400 chars"),
    FieldRule("SprintBoardId",    required=False, normalize=to_trim, check=max_len(200)),
    FieldRule("SprintStartDate",  required=False, normalize=to_dt,   check=is_datetime, message="Invalid SprintStartDate"),
    FieldRule("SprintEndDate",    required=False, normalize=to_dt,   check=is_datetime, message="Invalid SprintEndDate"),
    FieldRule("SprintCompletedDate", required=False, normalize=to_dt, check=is_datetime),
    FieldRule("SprintIsStarted",  required=False, normalize=to_bool),
    FieldRule("SprintIsClosed",   required=False, normalize=to_bool),
    FieldRule("SprintGoal",       required=False, normalize=to_trim, check=max_len(4000)),
    FieldRule("EventDate",        required=False, normalize=to_dt,   check=is_datetime),
]

ISSUE_RULES_DEFAULT: List[FieldRule] = [
    FieldRule("Issue",              required=True,  normalize=to_trim, check=lambda v: is_alnum_soft(v) and max_len(200)(v),
              message="Issue key required"),
    FieldRule("ProjectName",        required=False, normalize=to_trim, check=max_len(400)),
    FieldRule("IssueSummary",       required=False, normalize=to_trim, check=max_len(4000)),
    FieldRule("IssueTypeName",      required=False, normalize=to_trim, check=max_len(200)),
    FieldRule("IssueAssigneeName",  required=False, normalize=to_trim, check=max_len(400)),
    FieldRule("IssueParentKey",     required=False, normalize=to_trim, check=max_len(200)),
    FieldRule("IssueParentSummary", required=False, normalize=to_trim, check=max_len(4000)),
    FieldRule("IssueStatusName",    required=False, normalize=to_trim, check=max_len(200)),
    FieldRule("IssueStoryPoints",   required=False, normalize=to_float),
]

ASSIGN_RULES_DEFAULT: List[FieldRule] = [
    FieldRule("Issue",       required=True,  normalize=to_trim, check=lambda v: is_alnum_soft(v) and max_len(200)(v)),
    FieldRule("ProjectName", required=True,  normalize=to_trim, check=lambda v: is_alnum_soft(v) and max_len(400)(v)),
    FieldRule("SprintName",  required=True,  normalize=to_trim, check=lambda v: is_alnum_soft(v) and max_len(400)(v)),
    FieldRule("EventDate",   required=True,  normalize=to_dt,   check=is_datetime, message="EventDate must be a valid datetime"),
]

def sprint_crosscheck(row: Dict[str, Any]) -> Dict[str, str]:
    errs: Dict[str, str] = {}
    sd, ed, cd = row.get("SprintStartDate"), row.get("SprintEndDate"), row.get("SprintCompletedDate")
    if sd and ed and sd > ed:
        errs["SprintStartDate"] = "SprintStartDate must be <= SprintEndDate"
    if ed and cd and ed > cd:
        errs["SprintCompletedDate"] = "SprintCompletedDate should be >= SprintEndDate"
    return errs
