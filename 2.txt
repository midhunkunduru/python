def merge_sprint_rows(self, rows: List[Dict[str, Any]]):
    """Upsert into dbo.jira_sprint using MERGE + VALUES with batch-level dedup."""
    if not rows:
        return

    self._create_table_if_not_exists(self.TABLE_SPRINT, self.SPRINT_COLS, self.SPRINT_PK)
    cn = self.connect(); cur = cn.cursor()

    cols = [c for c, _ in self.SPRINT_COLS]
    pk_cols = ("ProjectName", "SprintName")
    src_cols = ", ".join(f"[{c}]" for c in cols)
    tgt_cols = src_cols
    assignments = ", ".join([f"T.[{c}] = S.[{c}]" for c in cols if c not in pk_cols])

    # ---- normalize + dedupe per batch ----
    def _norm(v): return None if v is None else str(v).strip()
    dedup: dict[tuple, Dict[str, Any]] = {}
    for r in rows:
        pn = _norm(r.get("ProjectName"))
        sn = _norm(r.get("SprintName"))
        if not pn or not sn:
            continue
        r = {**r, "ProjectName": pn, "SprintName": sn}
        dedup[(pn, sn)] = r
    rows = list(dedup.values())
    if not rows:
        cur.close(); return

    per_row_params = len(cols)
    max_rows = max(1, 2000 // per_row_params)

    def to_params(batch):
        for r in batch:
            for c in cols:
                yield r.get(c)

    i, n = 0, len(rows)
    while i < n:
        batch = rows[i:i + max_rows]; i += len(batch)
        row_ph = "(" + ", ".join(["?"] * per_row_params) + ")"
        values_clause = ", ".join([row_ph] * len(batch))

        merge_sql = f"""
MERGE {self.TABLE_SPRINT} WITH (HOLDLOCK) AS T
USING (VALUES {values_clause}) AS S ({src_cols})
  ON T.[ProjectName]=S.[ProjectName] AND T.[SprintName]=S.[SprintName]
WHEN MATCHED THEN UPDATE SET {assignments}
WHEN NOT MATCHED BY TARGET THEN INSERT ({tgt_cols}) VALUES ({src_cols});
"""
        cur.execute(merge_sql, list(to_params(batch)))

    cur.close()



def merge_assign_rows(self, rows: List[Dict[str, Any]]):
    """
    Idempotent upsert into dbo.jira_sprint_issue_assigned using MERGE + VALUES
    with dedup by (Issue, ProjectName, SprintName, EventDate).
    """
    if not rows:
        return

    self._create_table_if_not_exists(self.TABLE_ASSIGN, self.ASSIGN_COLS, self.ASSIGN_PK)
    cn = self.connect(); cur = cn.cursor()

    cols = [c for c, _ in self.ASSIGN_COLS]
    src_cols = ", ".join(f"[{c}]" for c in cols)
    tgt_cols = src_cols

    # ---- normalize + dedupe per batch ----
    def _norm(v): return None if v is None else str(v).strip()

    dedup: dict[tuple, Dict[str, Any]] = {}
    for r in rows:
        issue  = _norm(r.get("Issue"))
        proj   = _norm(r.get("ProjectName"))
        sprint = _norm(r.get("SprintName"))
        event  = r.get("EventDate")  # keep as datetime/None
        if not issue or not proj or sprint is None or event is None:
            # if you want to allow NULL EventDate, drop the 'event is None' check
            continue
        r = {**r, "Issue": issue, "ProjectName": proj, "SprintName": sprint, "EventDate": event}
        dedup[(issue, proj, sprint, event)] = r

    rows = list(dedup.values())
    if not rows:
        cur.close(); return

    per_row_params = len(cols)
    max_rows = max(1, 2000 // per_row_params)

    def to_params(batch):
        for r in batch:
            for c in cols:
                yield r.get(c)

    i, n = 0, len(rows)
    while i < n:
        batch = rows[i:i + max_rows]; i += len(batch)
        row_ph = "(" + ", ".join(["?"] * per_row_params) + ")"
        values_clause = ", ".join([row_ph] * len(batch))

        merge_sql = f"""
MERGE {self.TABLE_ASSIGN} WITH (HOLDLOCK) AS T
USING (VALUES {values_clause}) AS S ({src_cols})
  ON  T.[Issue]=S.[Issue]
  AND T.[ProjectName]=S.[ProjectName]
  AND T.[SprintName]=S.[SprintName]
  AND T.[EventDate]=S.[EventDate]
WHEN NOT MATCHED BY TARGET THEN
  INSERT ({tgt_cols}) VALUES ({src_cols});
"""
        cur.execute(merge_sql, list(to_params(batch)))

    cur.close()


-- 1) Add a proper identity PK if you need one
IF COL_LENGTH('dbo.jira_sprints', 'SprintId') IS NULL
    ALTER TABLE dbo.jira_sprints ADD SprintId INT IDENTITY(1,1) NOT NULL;

-- 2) Add a string column to store Jira board id (not identity)
IF COL_LENGTH('dbo.jira_sprints', 'SprintBoardKey') IS NULL
    ALTER TABLE dbo.jira_sprints ADD SprintBoardKey NVARCHAR(200) NULL;

-- 3) (Optional) If SprintBoardID (identity) was mistakenly used for Jira board id,
--    stop writing to it. You cannot drop IDENTITY property in-place; to remove it
--    youâ€™d need to recreate the table or add a new non-identity column and use that.




def _identity_columns(self, table: str) -> set[str]:
    cn = self.connect()
    cur = cn.cursor()
    cur.execute("""
        SELECT c.name
        FROM sys.identity_columns ic
        JOIN sys.columns c ON c.object_id = ic.object_id AND c.column_id = ic.column_id
        WHERE ic.object_id = OBJECT_ID(?)
    """, table)
    names = {row[0] for row in cur.fetchall()}
    cur.close()
    return names



def merge_sprint_rows(self, rows: List[Dict[str, Any]]):
    if not rows:
        return

    self._create_table_if_not_exists(self.TABLE_SPRINT, self.SPRINT_COLS, self.SPRINT_PK)
    cn = self.connect(); cur = cn.cursor()

    all_cols = [c for c, _ in self.SPRINT_COLS]
    id_cols  = self._identity_columns(self.TABLE_SPRINT)          # <-- new
    cols     = [c for c in all_cols if c not in id_cols]          # source columns (no identities)

    pk_cols = ("ProjectName", "SprintName")
    src_cols = ", ".join(f"[{c}]" for c in cols)
    tgt_cols = src_cols
    assignments = ", ".join([f"T.[{c}] = S.[{c}]" for c in cols if c not in pk_cols])

    # dedupe by natural key
    def _norm(v): return None if v is None else str(v).strip()
    dedup = {}
    for r in rows:
        pn, sn = _norm(r.get("ProjectName")), _norm(r.get("SprintName"))
        if not pn or not sn:
            continue
        # drop identity fields from payload if present
        for idc in id_cols:
            r.pop(idc, None)
        dedup[(pn, sn)] = {**r, "ProjectName": pn, "SprintName": sn}
    rows = list(dedup.values())
    if not rows:
        cur.close(); return

    per_row = len(cols)
    max_rows = max(1, 2000 // per_row)
    def params(batch):
        for r in batch:
            for c in cols:
                yield r.get(c)

    i = 0
    while i < len(rows):
        batch = rows[i:i+max_rows]; i += len(batch)
        row_ph = "(" + ", ".join(["?"] * per_row) + ")"
        values_clause = ", ".join([row_ph] * len(batch))
        merge_sql = f"""
MERGE {self.TABLE_SPRINT} WITH (HOLDLOCK) AS T
USING (VALUES {values_clause}) AS S ({src_cols})
  ON T.[ProjectName]=S.[ProjectName] AND T.[SprintName]=S.[SprintName]
WHEN MATCHED THEN UPDATE SET {assignments}
WHEN NOT MATCHED BY TARGET THEN INSERT ({tgt_cols}) VALUES ({src_cols});
"""
        cur.execute(merge_sql, list(params(batch)))

    cur.close()
    

    
    
