valid

from __future__ import annotations
import json, os, logging
from typing import Any, Dict, List, Tuple, Optional
from .loader import Database
from .jirasprintchangemgr import FieldRule, is_not_null

logger = logging.getLogger(__name__)

class ValidationResult:
    def __init__(self, ok: bool, errors: Dict[str, str], row: Dict[str, Any]):
        self.ok = ok
        self.errors = errors
        self.row = row

class RowValidator:
    def __init__(self, rules: List[FieldRule]):
        self.rules = rules

    def validate(self, row: Dict[str, Any]) -> ValidationResult:
        out, errs = dict(row), {}
        for r in self.rules:
            val = out.get(r.name)
            if r.normalize:
                try:
                    val = r.normalize(val)
                    out[r.name] = val
                except Exception:
                    errs[r.name] = r.message or f"{r.name} normalization failed"
                    continue
            if r.required and not is_not_null(val):
                errs[r.name] = r.message or f"{r.name} is required"
                continue
            if r.check and is_not_null(val):
                try:
                    ok = r.check(val)
                except Exception:
                    ok = False
                if not ok:
                    errs[r.name] = r.message or f"{r.name} failed validation"
        return ValidationResult(ok=(len(errs) == 0), errors=errs, row=out)


class EntityValidator:
    def __init__(self, rules: List[FieldRule],
                 crosscheck: Optional[callable[[Dict[str, Any]], Dict[str, str]]] = None):
        self.row_validator = RowValidator(rules)
        self.crosscheck = crosscheck or (lambda _row: {})

    def validate_rows(self, rows: List[Dict[str, Any]]) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
        good, bad = [], []
        for r in rows:
            res = self.row_validator.validate(r)
            if res.ok:
                xerrs = self.crosscheck(res.row)
                if xerrs:
                    bad.append({"why": xerrs, "row": r})
                else:
                    good.append(res.row)
            else:
                bad.append({"why": res.errors, "row": r})
        return good, bad


class DataQualityPipeline:
    def __init__(self, db: Database,
                 sprint_rules: List[FieldRule], issue_rules: List[FieldRule], assign_rules: List[FieldRule],
                 sprint_cross=None, issue_cross=None, assign_cross=None,
                 quarantine_dir: str = "./quarantine", logger_: Optional[logging.Logger] = None):
        self.db = db
        self.logger = logger_ or logging.getLogger(__name__)
        self.quarantine_dir = quarantine_dir
        os.makedirs(self.quarantine_dir, exist_ok=True)

        self.sprint_val = EntityValidator(sprint_rules, sprint_cross or (lambda r: {}))
        self.issue_val = EntityValidator(issue_rules, issue_cross or (lambda r: {}))
        self.assign_val = EntityValidator(assign_rules, assign_cross or (lambda r: {}))

    def _qwrite(self, name: str, records: List[Dict[str, Any]]):
        if not records:
            return
        path = os.path.join(self.quarantine_dir, name)
        with open(path, "a", encoding="utf-8") as f:
            for rec in records:
                f.write(json.dumps(rec, default=str) + "\n")

    def run_and_load(self, sprint_rows, issue_rows, assign_rows):
        gs, bs = self.sprint_val.validate_rows(sprint_rows)
        gi, bi = self.issue_val.validate_rows(issue_rows)
        ga, ba = self.assign_val.validate_rows(assign_rows)

        self._qwrite("invalid_sprints.jsonl", bs)
        self._qwrite("invalid_issues.jsonl", bi)
        self._qwrite("invalid_assignments.jsonl", ba)

        self.logger.info(
            "Validation summary: sprints ok=%d bad=%d | issues ok=%d bad=%d | assigns ok=%d bad=%d",
            len(gs), len(bs), len(gi), len(bi), len(ga), len(ba)
        )

        gs = self.db.coerce_rows_to_table_schema(self.db.tables.jira_sprint, gs)
        gi = self.db.coerce_rows_to_table_schema(self.db.tables.jira_issue, gi)
        ga = self.db.coerce_rows_to_table_schema(self.db.tables.jira_assign, ga)

        self.db.merge_rows(self.db.tables.jira_sprint, gs, key_cols=("ProjectName", "SprintName"))
        self.db.merge_rows(self.db.tables.jira_issue, gi, key_cols=("Issue",))
        self.db.merge_rows(self.db.tables.jira_assign, ga, key_cols=("Issue", "ProjectName", "SprintName"))

        return {
            "sprint_ok": len(gs), "sprint_bad": len(bs),
            "issue_ok": len(gi), "issue_bad": len(bi),
            "assign_ok": len(ga), "assign_bad": len(ba)
        }
